// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package multirun

//go:generate minimock -i github.com/anton-martsiushkou/github_actions_multirun/multirun.Github -o github_mock_test.go -n GithubMock -p multirun

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// GithubMock implements Github
type GithubMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelWorkflowRun          func(ctx context.Context, owner string, repo string, runID int64) (err error)
	inspectFuncCancelWorkflowRun   func(ctx context.Context, owner string, repo string, runID int64)
	afterCancelWorkflowRunCounter  uint64
	beforeCancelWorkflowRunCounter uint64
	CancelWorkflowRunMock          mGithubMockCancelWorkflowRun

	funcGetLastWorkflowRunNumber          func(ctx context.Context, owner string, repo string, workflowName string) (i1 int, err error)
	inspectFuncGetLastWorkflowRunNumber   func(ctx context.Context, owner string, repo string, workflowName string)
	afterGetLastWorkflowRunNumberCounter  uint64
	beforeGetLastWorkflowRunNumberCounter uint64
	GetLastWorkflowRunNumberMock          mGithubMockGetLastWorkflowRunNumber

	funcGetWorkflowRunID          func(ctx context.Context, owner string, repo string, workflowName string, minRunVersion int) (i1 int64, err error)
	inspectFuncGetWorkflowRunID   func(ctx context.Context, owner string, repo string, workflowName string, minRunVersion int)
	afterGetWorkflowRunIDCounter  uint64
	beforeGetWorkflowRunIDCounter uint64
	GetWorkflowRunIDMock          mGithubMockGetWorkflowRunID

	funcGetWorkflowRunStatus          func(ctx context.Context, owner string, repo string, runID int64) (s1 string, s2 string, d1 time.Duration, err error)
	inspectFuncGetWorkflowRunStatus   func(ctx context.Context, owner string, repo string, runID int64)
	afterGetWorkflowRunStatusCounter  uint64
	beforeGetWorkflowRunStatusCounter uint64
	GetWorkflowRunStatusMock          mGithubMockGetWorkflowRunStatus

	funcTriggerWorkflow          func(ctx context.Context, owner string, repo string, workflow string, eventType string, params map[string]interface{}) (err error)
	inspectFuncTriggerWorkflow   func(ctx context.Context, owner string, repo string, workflow string, eventType string, params map[string]interface{})
	afterTriggerWorkflowCounter  uint64
	beforeTriggerWorkflowCounter uint64
	TriggerWorkflowMock          mGithubMockTriggerWorkflow
}

// NewGithubMock returns a mock for Github
func NewGithubMock(t minimock.Tester) *GithubMock {
	m := &GithubMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelWorkflowRunMock = mGithubMockCancelWorkflowRun{mock: m}
	m.CancelWorkflowRunMock.callArgs = []*GithubMockCancelWorkflowRunParams{}

	m.GetLastWorkflowRunNumberMock = mGithubMockGetLastWorkflowRunNumber{mock: m}
	m.GetLastWorkflowRunNumberMock.callArgs = []*GithubMockGetLastWorkflowRunNumberParams{}

	m.GetWorkflowRunIDMock = mGithubMockGetWorkflowRunID{mock: m}
	m.GetWorkflowRunIDMock.callArgs = []*GithubMockGetWorkflowRunIDParams{}

	m.GetWorkflowRunStatusMock = mGithubMockGetWorkflowRunStatus{mock: m}
	m.GetWorkflowRunStatusMock.callArgs = []*GithubMockGetWorkflowRunStatusParams{}

	m.TriggerWorkflowMock = mGithubMockTriggerWorkflow{mock: m}
	m.TriggerWorkflowMock.callArgs = []*GithubMockTriggerWorkflowParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mGithubMockCancelWorkflowRun struct {
	optional           bool
	mock               *GithubMock
	defaultExpectation *GithubMockCancelWorkflowRunExpectation
	expectations       []*GithubMockCancelWorkflowRunExpectation

	callArgs []*GithubMockCancelWorkflowRunParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// GithubMockCancelWorkflowRunExpectation specifies expectation struct of the Github.CancelWorkflowRun
type GithubMockCancelWorkflowRunExpectation struct {
	mock      *GithubMock
	params    *GithubMockCancelWorkflowRunParams
	paramPtrs *GithubMockCancelWorkflowRunParamPtrs
	results   *GithubMockCancelWorkflowRunResults
	Counter   uint64
}

// GithubMockCancelWorkflowRunParams contains parameters of the Github.CancelWorkflowRun
type GithubMockCancelWorkflowRunParams struct {
	ctx   context.Context
	owner string
	repo  string
	runID int64
}

// GithubMockCancelWorkflowRunParamPtrs contains pointers to parameters of the Github.CancelWorkflowRun
type GithubMockCancelWorkflowRunParamPtrs struct {
	ctx   *context.Context
	owner *string
	repo  *string
	runID *int64
}

// GithubMockCancelWorkflowRunResults contains results of the Github.CancelWorkflowRun
type GithubMockCancelWorkflowRunResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) Optional() *mGithubMockCancelWorkflowRun {
	mmCancelWorkflowRun.optional = true
	return mmCancelWorkflowRun
}

// Expect sets up expected params for Github.CancelWorkflowRun
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) Expect(ctx context.Context, owner string, repo string, runID int64) *mGithubMockCancelWorkflowRun {
	if mmCancelWorkflowRun.mock.funcCancelWorkflowRun != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Set")
	}

	if mmCancelWorkflowRun.defaultExpectation == nil {
		mmCancelWorkflowRun.defaultExpectation = &GithubMockCancelWorkflowRunExpectation{}
	}

	if mmCancelWorkflowRun.defaultExpectation.paramPtrs != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by ExpectParams functions")
	}

	mmCancelWorkflowRun.defaultExpectation.params = &GithubMockCancelWorkflowRunParams{ctx, owner, repo, runID}
	for _, e := range mmCancelWorkflowRun.expectations {
		if minimock.Equal(e.params, mmCancelWorkflowRun.defaultExpectation.params) {
			mmCancelWorkflowRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelWorkflowRun.defaultExpectation.params)
		}
	}

	return mmCancelWorkflowRun
}

// ExpectCtxParam1 sets up expected param ctx for Github.CancelWorkflowRun
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) ExpectCtxParam1(ctx context.Context) *mGithubMockCancelWorkflowRun {
	if mmCancelWorkflowRun.mock.funcCancelWorkflowRun != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Set")
	}

	if mmCancelWorkflowRun.defaultExpectation == nil {
		mmCancelWorkflowRun.defaultExpectation = &GithubMockCancelWorkflowRunExpectation{}
	}

	if mmCancelWorkflowRun.defaultExpectation.params != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Expect")
	}

	if mmCancelWorkflowRun.defaultExpectation.paramPtrs == nil {
		mmCancelWorkflowRun.defaultExpectation.paramPtrs = &GithubMockCancelWorkflowRunParamPtrs{}
	}
	mmCancelWorkflowRun.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCancelWorkflowRun
}

// ExpectOwnerParam2 sets up expected param owner for Github.CancelWorkflowRun
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) ExpectOwnerParam2(owner string) *mGithubMockCancelWorkflowRun {
	if mmCancelWorkflowRun.mock.funcCancelWorkflowRun != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Set")
	}

	if mmCancelWorkflowRun.defaultExpectation == nil {
		mmCancelWorkflowRun.defaultExpectation = &GithubMockCancelWorkflowRunExpectation{}
	}

	if mmCancelWorkflowRun.defaultExpectation.params != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Expect")
	}

	if mmCancelWorkflowRun.defaultExpectation.paramPtrs == nil {
		mmCancelWorkflowRun.defaultExpectation.paramPtrs = &GithubMockCancelWorkflowRunParamPtrs{}
	}
	mmCancelWorkflowRun.defaultExpectation.paramPtrs.owner = &owner

	return mmCancelWorkflowRun
}

// ExpectRepoParam3 sets up expected param repo for Github.CancelWorkflowRun
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) ExpectRepoParam3(repo string) *mGithubMockCancelWorkflowRun {
	if mmCancelWorkflowRun.mock.funcCancelWorkflowRun != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Set")
	}

	if mmCancelWorkflowRun.defaultExpectation == nil {
		mmCancelWorkflowRun.defaultExpectation = &GithubMockCancelWorkflowRunExpectation{}
	}

	if mmCancelWorkflowRun.defaultExpectation.params != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Expect")
	}

	if mmCancelWorkflowRun.defaultExpectation.paramPtrs == nil {
		mmCancelWorkflowRun.defaultExpectation.paramPtrs = &GithubMockCancelWorkflowRunParamPtrs{}
	}
	mmCancelWorkflowRun.defaultExpectation.paramPtrs.repo = &repo

	return mmCancelWorkflowRun
}

// ExpectRunIDParam4 sets up expected param runID for Github.CancelWorkflowRun
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) ExpectRunIDParam4(runID int64) *mGithubMockCancelWorkflowRun {
	if mmCancelWorkflowRun.mock.funcCancelWorkflowRun != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Set")
	}

	if mmCancelWorkflowRun.defaultExpectation == nil {
		mmCancelWorkflowRun.defaultExpectation = &GithubMockCancelWorkflowRunExpectation{}
	}

	if mmCancelWorkflowRun.defaultExpectation.params != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Expect")
	}

	if mmCancelWorkflowRun.defaultExpectation.paramPtrs == nil {
		mmCancelWorkflowRun.defaultExpectation.paramPtrs = &GithubMockCancelWorkflowRunParamPtrs{}
	}
	mmCancelWorkflowRun.defaultExpectation.paramPtrs.runID = &runID

	return mmCancelWorkflowRun
}

// Inspect accepts an inspector function that has same arguments as the Github.CancelWorkflowRun
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) Inspect(f func(ctx context.Context, owner string, repo string, runID int64)) *mGithubMockCancelWorkflowRun {
	if mmCancelWorkflowRun.mock.inspectFuncCancelWorkflowRun != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("Inspect function is already set for GithubMock.CancelWorkflowRun")
	}

	mmCancelWorkflowRun.mock.inspectFuncCancelWorkflowRun = f

	return mmCancelWorkflowRun
}

// Return sets up results that will be returned by Github.CancelWorkflowRun
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) Return(err error) *GithubMock {
	if mmCancelWorkflowRun.mock.funcCancelWorkflowRun != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Set")
	}

	if mmCancelWorkflowRun.defaultExpectation == nil {
		mmCancelWorkflowRun.defaultExpectation = &GithubMockCancelWorkflowRunExpectation{mock: mmCancelWorkflowRun.mock}
	}
	mmCancelWorkflowRun.defaultExpectation.results = &GithubMockCancelWorkflowRunResults{err}
	return mmCancelWorkflowRun.mock
}

// Set uses given function f to mock the Github.CancelWorkflowRun method
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) Set(f func(ctx context.Context, owner string, repo string, runID int64) (err error)) *GithubMock {
	if mmCancelWorkflowRun.defaultExpectation != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("Default expectation is already set for the Github.CancelWorkflowRun method")
	}

	if len(mmCancelWorkflowRun.expectations) > 0 {
		mmCancelWorkflowRun.mock.t.Fatalf("Some expectations are already set for the Github.CancelWorkflowRun method")
	}

	mmCancelWorkflowRun.mock.funcCancelWorkflowRun = f
	return mmCancelWorkflowRun.mock
}

// When sets expectation for the Github.CancelWorkflowRun which will trigger the result defined by the following
// Then helper
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) When(ctx context.Context, owner string, repo string, runID int64) *GithubMockCancelWorkflowRunExpectation {
	if mmCancelWorkflowRun.mock.funcCancelWorkflowRun != nil {
		mmCancelWorkflowRun.mock.t.Fatalf("GithubMock.CancelWorkflowRun mock is already set by Set")
	}

	expectation := &GithubMockCancelWorkflowRunExpectation{
		mock:   mmCancelWorkflowRun.mock,
		params: &GithubMockCancelWorkflowRunParams{ctx, owner, repo, runID},
	}
	mmCancelWorkflowRun.expectations = append(mmCancelWorkflowRun.expectations, expectation)
	return expectation
}

// Then sets up Github.CancelWorkflowRun return parameters for the expectation previously defined by the When method
func (e *GithubMockCancelWorkflowRunExpectation) Then(err error) *GithubMock {
	e.results = &GithubMockCancelWorkflowRunResults{err}
	return e.mock
}

// Times sets number of times Github.CancelWorkflowRun should be invoked
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) Times(n uint64) *mGithubMockCancelWorkflowRun {
	if n == 0 {
		mmCancelWorkflowRun.mock.t.Fatalf("Times of GithubMock.CancelWorkflowRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelWorkflowRun.expectedInvocations, n)
	return mmCancelWorkflowRun
}

func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) invocationsDone() bool {
	if len(mmCancelWorkflowRun.expectations) == 0 && mmCancelWorkflowRun.defaultExpectation == nil && mmCancelWorkflowRun.mock.funcCancelWorkflowRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelWorkflowRun.mock.afterCancelWorkflowRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelWorkflowRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelWorkflowRun implements Github
func (mmCancelWorkflowRun *GithubMock) CancelWorkflowRun(ctx context.Context, owner string, repo string, runID int64) (err error) {
	mm_atomic.AddUint64(&mmCancelWorkflowRun.beforeCancelWorkflowRunCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelWorkflowRun.afterCancelWorkflowRunCounter, 1)

	if mmCancelWorkflowRun.inspectFuncCancelWorkflowRun != nil {
		mmCancelWorkflowRun.inspectFuncCancelWorkflowRun(ctx, owner, repo, runID)
	}

	mm_params := GithubMockCancelWorkflowRunParams{ctx, owner, repo, runID}

	// Record call args
	mmCancelWorkflowRun.CancelWorkflowRunMock.mutex.Lock()
	mmCancelWorkflowRun.CancelWorkflowRunMock.callArgs = append(mmCancelWorkflowRun.CancelWorkflowRunMock.callArgs, &mm_params)
	mmCancelWorkflowRun.CancelWorkflowRunMock.mutex.Unlock()

	for _, e := range mmCancelWorkflowRun.CancelWorkflowRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelWorkflowRun.CancelWorkflowRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelWorkflowRun.CancelWorkflowRunMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelWorkflowRun.CancelWorkflowRunMock.defaultExpectation.params
		mm_want_ptrs := mmCancelWorkflowRun.CancelWorkflowRunMock.defaultExpectation.paramPtrs

		mm_got := GithubMockCancelWorkflowRunParams{ctx, owner, repo, runID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCancelWorkflowRun.t.Errorf("GithubMock.CancelWorkflowRun got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.owner != nil && !minimock.Equal(*mm_want_ptrs.owner, mm_got.owner) {
				mmCancelWorkflowRun.t.Errorf("GithubMock.CancelWorkflowRun got unexpected parameter owner, want: %#v, got: %#v%s\n", *mm_want_ptrs.owner, mm_got.owner, minimock.Diff(*mm_want_ptrs.owner, mm_got.owner))
			}

			if mm_want_ptrs.repo != nil && !minimock.Equal(*mm_want_ptrs.repo, mm_got.repo) {
				mmCancelWorkflowRun.t.Errorf("GithubMock.CancelWorkflowRun got unexpected parameter repo, want: %#v, got: %#v%s\n", *mm_want_ptrs.repo, mm_got.repo, minimock.Diff(*mm_want_ptrs.repo, mm_got.repo))
			}

			if mm_want_ptrs.runID != nil && !minimock.Equal(*mm_want_ptrs.runID, mm_got.runID) {
				mmCancelWorkflowRun.t.Errorf("GithubMock.CancelWorkflowRun got unexpected parameter runID, want: %#v, got: %#v%s\n", *mm_want_ptrs.runID, mm_got.runID, minimock.Diff(*mm_want_ptrs.runID, mm_got.runID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelWorkflowRun.t.Errorf("GithubMock.CancelWorkflowRun got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelWorkflowRun.CancelWorkflowRunMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelWorkflowRun.t.Fatal("No results are set for the GithubMock.CancelWorkflowRun")
		}
		return (*mm_results).err
	}
	if mmCancelWorkflowRun.funcCancelWorkflowRun != nil {
		return mmCancelWorkflowRun.funcCancelWorkflowRun(ctx, owner, repo, runID)
	}
	mmCancelWorkflowRun.t.Fatalf("Unexpected call to GithubMock.CancelWorkflowRun. %v %v %v %v", ctx, owner, repo, runID)
	return
}

// CancelWorkflowRunAfterCounter returns a count of finished GithubMock.CancelWorkflowRun invocations
func (mmCancelWorkflowRun *GithubMock) CancelWorkflowRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelWorkflowRun.afterCancelWorkflowRunCounter)
}

// CancelWorkflowRunBeforeCounter returns a count of GithubMock.CancelWorkflowRun invocations
func (mmCancelWorkflowRun *GithubMock) CancelWorkflowRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelWorkflowRun.beforeCancelWorkflowRunCounter)
}

// Calls returns a list of arguments used in each call to GithubMock.CancelWorkflowRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelWorkflowRun *mGithubMockCancelWorkflowRun) Calls() []*GithubMockCancelWorkflowRunParams {
	mmCancelWorkflowRun.mutex.RLock()

	argCopy := make([]*GithubMockCancelWorkflowRunParams, len(mmCancelWorkflowRun.callArgs))
	copy(argCopy, mmCancelWorkflowRun.callArgs)

	mmCancelWorkflowRun.mutex.RUnlock()

	return argCopy
}

// MinimockCancelWorkflowRunDone returns true if the count of the CancelWorkflowRun invocations corresponds
// the number of defined expectations
func (m *GithubMock) MinimockCancelWorkflowRunDone() bool {
	if m.CancelWorkflowRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelWorkflowRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelWorkflowRunMock.invocationsDone()
}

// MinimockCancelWorkflowRunInspect logs each unmet expectation
func (m *GithubMock) MinimockCancelWorkflowRunInspect() {
	for _, e := range m.CancelWorkflowRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GithubMock.CancelWorkflowRun with params: %#v", *e.params)
		}
	}

	afterCancelWorkflowRunCounter := mm_atomic.LoadUint64(&m.afterCancelWorkflowRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelWorkflowRunMock.defaultExpectation != nil && afterCancelWorkflowRunCounter < 1 {
		if m.CancelWorkflowRunMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GithubMock.CancelWorkflowRun")
		} else {
			m.t.Errorf("Expected call to GithubMock.CancelWorkflowRun with params: %#v", *m.CancelWorkflowRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelWorkflowRun != nil && afterCancelWorkflowRunCounter < 1 {
		m.t.Error("Expected call to GithubMock.CancelWorkflowRun")
	}

	if !m.CancelWorkflowRunMock.invocationsDone() && afterCancelWorkflowRunCounter > 0 {
		m.t.Errorf("Expected %d calls to GithubMock.CancelWorkflowRun but found %d calls",
			mm_atomic.LoadUint64(&m.CancelWorkflowRunMock.expectedInvocations), afterCancelWorkflowRunCounter)
	}
}

type mGithubMockGetLastWorkflowRunNumber struct {
	optional           bool
	mock               *GithubMock
	defaultExpectation *GithubMockGetLastWorkflowRunNumberExpectation
	expectations       []*GithubMockGetLastWorkflowRunNumberExpectation

	callArgs []*GithubMockGetLastWorkflowRunNumberParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// GithubMockGetLastWorkflowRunNumberExpectation specifies expectation struct of the Github.GetLastWorkflowRunNumber
type GithubMockGetLastWorkflowRunNumberExpectation struct {
	mock      *GithubMock
	params    *GithubMockGetLastWorkflowRunNumberParams
	paramPtrs *GithubMockGetLastWorkflowRunNumberParamPtrs
	results   *GithubMockGetLastWorkflowRunNumberResults
	Counter   uint64
}

// GithubMockGetLastWorkflowRunNumberParams contains parameters of the Github.GetLastWorkflowRunNumber
type GithubMockGetLastWorkflowRunNumberParams struct {
	ctx          context.Context
	owner        string
	repo         string
	workflowName string
}

// GithubMockGetLastWorkflowRunNumberParamPtrs contains pointers to parameters of the Github.GetLastWorkflowRunNumber
type GithubMockGetLastWorkflowRunNumberParamPtrs struct {
	ctx          *context.Context
	owner        *string
	repo         *string
	workflowName *string
}

// GithubMockGetLastWorkflowRunNumberResults contains results of the Github.GetLastWorkflowRunNumber
type GithubMockGetLastWorkflowRunNumberResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) Optional() *mGithubMockGetLastWorkflowRunNumber {
	mmGetLastWorkflowRunNumber.optional = true
	return mmGetLastWorkflowRunNumber
}

// Expect sets up expected params for Github.GetLastWorkflowRunNumber
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) Expect(ctx context.Context, owner string, repo string, workflowName string) *mGithubMockGetLastWorkflowRunNumber {
	if mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Set")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation = &GithubMockGetLastWorkflowRunNumberExpectation{}
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by ExpectParams functions")
	}

	mmGetLastWorkflowRunNumber.defaultExpectation.params = &GithubMockGetLastWorkflowRunNumberParams{ctx, owner, repo, workflowName}
	for _, e := range mmGetLastWorkflowRunNumber.expectations {
		if minimock.Equal(e.params, mmGetLastWorkflowRunNumber.defaultExpectation.params) {
			mmGetLastWorkflowRunNumber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLastWorkflowRunNumber.defaultExpectation.params)
		}
	}

	return mmGetLastWorkflowRunNumber
}

// ExpectCtxParam1 sets up expected param ctx for Github.GetLastWorkflowRunNumber
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) ExpectCtxParam1(ctx context.Context) *mGithubMockGetLastWorkflowRunNumber {
	if mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Set")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation = &GithubMockGetLastWorkflowRunNumberExpectation{}
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.params != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Expect")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs = &GithubMockGetLastWorkflowRunNumberParamPtrs{}
	}
	mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetLastWorkflowRunNumber
}

// ExpectOwnerParam2 sets up expected param owner for Github.GetLastWorkflowRunNumber
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) ExpectOwnerParam2(owner string) *mGithubMockGetLastWorkflowRunNumber {
	if mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Set")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation = &GithubMockGetLastWorkflowRunNumberExpectation{}
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.params != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Expect")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs = &GithubMockGetLastWorkflowRunNumberParamPtrs{}
	}
	mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs.owner = &owner

	return mmGetLastWorkflowRunNumber
}

// ExpectRepoParam3 sets up expected param repo for Github.GetLastWorkflowRunNumber
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) ExpectRepoParam3(repo string) *mGithubMockGetLastWorkflowRunNumber {
	if mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Set")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation = &GithubMockGetLastWorkflowRunNumberExpectation{}
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.params != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Expect")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs = &GithubMockGetLastWorkflowRunNumberParamPtrs{}
	}
	mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs.repo = &repo

	return mmGetLastWorkflowRunNumber
}

// ExpectWorkflowNameParam4 sets up expected param workflowName for Github.GetLastWorkflowRunNumber
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) ExpectWorkflowNameParam4(workflowName string) *mGithubMockGetLastWorkflowRunNumber {
	if mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Set")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation = &GithubMockGetLastWorkflowRunNumberExpectation{}
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.params != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Expect")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs = &GithubMockGetLastWorkflowRunNumberParamPtrs{}
	}
	mmGetLastWorkflowRunNumber.defaultExpectation.paramPtrs.workflowName = &workflowName

	return mmGetLastWorkflowRunNumber
}

// Inspect accepts an inspector function that has same arguments as the Github.GetLastWorkflowRunNumber
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) Inspect(f func(ctx context.Context, owner string, repo string, workflowName string)) *mGithubMockGetLastWorkflowRunNumber {
	if mmGetLastWorkflowRunNumber.mock.inspectFuncGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("Inspect function is already set for GithubMock.GetLastWorkflowRunNumber")
	}

	mmGetLastWorkflowRunNumber.mock.inspectFuncGetLastWorkflowRunNumber = f

	return mmGetLastWorkflowRunNumber
}

// Return sets up results that will be returned by Github.GetLastWorkflowRunNumber
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) Return(i1 int, err error) *GithubMock {
	if mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Set")
	}

	if mmGetLastWorkflowRunNumber.defaultExpectation == nil {
		mmGetLastWorkflowRunNumber.defaultExpectation = &GithubMockGetLastWorkflowRunNumberExpectation{mock: mmGetLastWorkflowRunNumber.mock}
	}
	mmGetLastWorkflowRunNumber.defaultExpectation.results = &GithubMockGetLastWorkflowRunNumberResults{i1, err}
	return mmGetLastWorkflowRunNumber.mock
}

// Set uses given function f to mock the Github.GetLastWorkflowRunNumber method
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) Set(f func(ctx context.Context, owner string, repo string, workflowName string) (i1 int, err error)) *GithubMock {
	if mmGetLastWorkflowRunNumber.defaultExpectation != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("Default expectation is already set for the Github.GetLastWorkflowRunNumber method")
	}

	if len(mmGetLastWorkflowRunNumber.expectations) > 0 {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("Some expectations are already set for the Github.GetLastWorkflowRunNumber method")
	}

	mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber = f
	return mmGetLastWorkflowRunNumber.mock
}

// When sets expectation for the Github.GetLastWorkflowRunNumber which will trigger the result defined by the following
// Then helper
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) When(ctx context.Context, owner string, repo string, workflowName string) *GithubMockGetLastWorkflowRunNumberExpectation {
	if mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("GithubMock.GetLastWorkflowRunNumber mock is already set by Set")
	}

	expectation := &GithubMockGetLastWorkflowRunNumberExpectation{
		mock:   mmGetLastWorkflowRunNumber.mock,
		params: &GithubMockGetLastWorkflowRunNumberParams{ctx, owner, repo, workflowName},
	}
	mmGetLastWorkflowRunNumber.expectations = append(mmGetLastWorkflowRunNumber.expectations, expectation)
	return expectation
}

// Then sets up Github.GetLastWorkflowRunNumber return parameters for the expectation previously defined by the When method
func (e *GithubMockGetLastWorkflowRunNumberExpectation) Then(i1 int, err error) *GithubMock {
	e.results = &GithubMockGetLastWorkflowRunNumberResults{i1, err}
	return e.mock
}

// Times sets number of times Github.GetLastWorkflowRunNumber should be invoked
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) Times(n uint64) *mGithubMockGetLastWorkflowRunNumber {
	if n == 0 {
		mmGetLastWorkflowRunNumber.mock.t.Fatalf("Times of GithubMock.GetLastWorkflowRunNumber mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLastWorkflowRunNumber.expectedInvocations, n)
	return mmGetLastWorkflowRunNumber
}

func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) invocationsDone() bool {
	if len(mmGetLastWorkflowRunNumber.expectations) == 0 && mmGetLastWorkflowRunNumber.defaultExpectation == nil && mmGetLastWorkflowRunNumber.mock.funcGetLastWorkflowRunNumber == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLastWorkflowRunNumber.mock.afterGetLastWorkflowRunNumberCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLastWorkflowRunNumber.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLastWorkflowRunNumber implements Github
func (mmGetLastWorkflowRunNumber *GithubMock) GetLastWorkflowRunNumber(ctx context.Context, owner string, repo string, workflowName string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetLastWorkflowRunNumber.beforeGetLastWorkflowRunNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLastWorkflowRunNumber.afterGetLastWorkflowRunNumberCounter, 1)

	if mmGetLastWorkflowRunNumber.inspectFuncGetLastWorkflowRunNumber != nil {
		mmGetLastWorkflowRunNumber.inspectFuncGetLastWorkflowRunNumber(ctx, owner, repo, workflowName)
	}

	mm_params := GithubMockGetLastWorkflowRunNumberParams{ctx, owner, repo, workflowName}

	// Record call args
	mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.mutex.Lock()
	mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.callArgs = append(mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.callArgs, &mm_params)
	mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.mutex.Unlock()

	for _, e := range mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.defaultExpectation.params
		mm_want_ptrs := mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.defaultExpectation.paramPtrs

		mm_got := GithubMockGetLastWorkflowRunNumberParams{ctx, owner, repo, workflowName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLastWorkflowRunNumber.t.Errorf("GithubMock.GetLastWorkflowRunNumber got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.owner != nil && !minimock.Equal(*mm_want_ptrs.owner, mm_got.owner) {
				mmGetLastWorkflowRunNumber.t.Errorf("GithubMock.GetLastWorkflowRunNumber got unexpected parameter owner, want: %#v, got: %#v%s\n", *mm_want_ptrs.owner, mm_got.owner, minimock.Diff(*mm_want_ptrs.owner, mm_got.owner))
			}

			if mm_want_ptrs.repo != nil && !minimock.Equal(*mm_want_ptrs.repo, mm_got.repo) {
				mmGetLastWorkflowRunNumber.t.Errorf("GithubMock.GetLastWorkflowRunNumber got unexpected parameter repo, want: %#v, got: %#v%s\n", *mm_want_ptrs.repo, mm_got.repo, minimock.Diff(*mm_want_ptrs.repo, mm_got.repo))
			}

			if mm_want_ptrs.workflowName != nil && !minimock.Equal(*mm_want_ptrs.workflowName, mm_got.workflowName) {
				mmGetLastWorkflowRunNumber.t.Errorf("GithubMock.GetLastWorkflowRunNumber got unexpected parameter workflowName, want: %#v, got: %#v%s\n", *mm_want_ptrs.workflowName, mm_got.workflowName, minimock.Diff(*mm_want_ptrs.workflowName, mm_got.workflowName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLastWorkflowRunNumber.t.Errorf("GithubMock.GetLastWorkflowRunNumber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLastWorkflowRunNumber.GetLastWorkflowRunNumberMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLastWorkflowRunNumber.t.Fatal("No results are set for the GithubMock.GetLastWorkflowRunNumber")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetLastWorkflowRunNumber.funcGetLastWorkflowRunNumber != nil {
		return mmGetLastWorkflowRunNumber.funcGetLastWorkflowRunNumber(ctx, owner, repo, workflowName)
	}
	mmGetLastWorkflowRunNumber.t.Fatalf("Unexpected call to GithubMock.GetLastWorkflowRunNumber. %v %v %v %v", ctx, owner, repo, workflowName)
	return
}

// GetLastWorkflowRunNumberAfterCounter returns a count of finished GithubMock.GetLastWorkflowRunNumber invocations
func (mmGetLastWorkflowRunNumber *GithubMock) GetLastWorkflowRunNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastWorkflowRunNumber.afterGetLastWorkflowRunNumberCounter)
}

// GetLastWorkflowRunNumberBeforeCounter returns a count of GithubMock.GetLastWorkflowRunNumber invocations
func (mmGetLastWorkflowRunNumber *GithubMock) GetLastWorkflowRunNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastWorkflowRunNumber.beforeGetLastWorkflowRunNumberCounter)
}

// Calls returns a list of arguments used in each call to GithubMock.GetLastWorkflowRunNumber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLastWorkflowRunNumber *mGithubMockGetLastWorkflowRunNumber) Calls() []*GithubMockGetLastWorkflowRunNumberParams {
	mmGetLastWorkflowRunNumber.mutex.RLock()

	argCopy := make([]*GithubMockGetLastWorkflowRunNumberParams, len(mmGetLastWorkflowRunNumber.callArgs))
	copy(argCopy, mmGetLastWorkflowRunNumber.callArgs)

	mmGetLastWorkflowRunNumber.mutex.RUnlock()

	return argCopy
}

// MinimockGetLastWorkflowRunNumberDone returns true if the count of the GetLastWorkflowRunNumber invocations corresponds
// the number of defined expectations
func (m *GithubMock) MinimockGetLastWorkflowRunNumberDone() bool {
	if m.GetLastWorkflowRunNumberMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLastWorkflowRunNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLastWorkflowRunNumberMock.invocationsDone()
}

// MinimockGetLastWorkflowRunNumberInspect logs each unmet expectation
func (m *GithubMock) MinimockGetLastWorkflowRunNumberInspect() {
	for _, e := range m.GetLastWorkflowRunNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GithubMock.GetLastWorkflowRunNumber with params: %#v", *e.params)
		}
	}

	afterGetLastWorkflowRunNumberCounter := mm_atomic.LoadUint64(&m.afterGetLastWorkflowRunNumberCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastWorkflowRunNumberMock.defaultExpectation != nil && afterGetLastWorkflowRunNumberCounter < 1 {
		if m.GetLastWorkflowRunNumberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GithubMock.GetLastWorkflowRunNumber")
		} else {
			m.t.Errorf("Expected call to GithubMock.GetLastWorkflowRunNumber with params: %#v", *m.GetLastWorkflowRunNumberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastWorkflowRunNumber != nil && afterGetLastWorkflowRunNumberCounter < 1 {
		m.t.Error("Expected call to GithubMock.GetLastWorkflowRunNumber")
	}

	if !m.GetLastWorkflowRunNumberMock.invocationsDone() && afterGetLastWorkflowRunNumberCounter > 0 {
		m.t.Errorf("Expected %d calls to GithubMock.GetLastWorkflowRunNumber but found %d calls",
			mm_atomic.LoadUint64(&m.GetLastWorkflowRunNumberMock.expectedInvocations), afterGetLastWorkflowRunNumberCounter)
	}
}

type mGithubMockGetWorkflowRunID struct {
	optional           bool
	mock               *GithubMock
	defaultExpectation *GithubMockGetWorkflowRunIDExpectation
	expectations       []*GithubMockGetWorkflowRunIDExpectation

	callArgs []*GithubMockGetWorkflowRunIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// GithubMockGetWorkflowRunIDExpectation specifies expectation struct of the Github.GetWorkflowRunID
type GithubMockGetWorkflowRunIDExpectation struct {
	mock      *GithubMock
	params    *GithubMockGetWorkflowRunIDParams
	paramPtrs *GithubMockGetWorkflowRunIDParamPtrs
	results   *GithubMockGetWorkflowRunIDResults
	Counter   uint64
}

// GithubMockGetWorkflowRunIDParams contains parameters of the Github.GetWorkflowRunID
type GithubMockGetWorkflowRunIDParams struct {
	ctx           context.Context
	owner         string
	repo          string
	workflowName  string
	minRunVersion int
}

// GithubMockGetWorkflowRunIDParamPtrs contains pointers to parameters of the Github.GetWorkflowRunID
type GithubMockGetWorkflowRunIDParamPtrs struct {
	ctx           *context.Context
	owner         *string
	repo          *string
	workflowName  *string
	minRunVersion *int
}

// GithubMockGetWorkflowRunIDResults contains results of the Github.GetWorkflowRunID
type GithubMockGetWorkflowRunIDResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) Optional() *mGithubMockGetWorkflowRunID {
	mmGetWorkflowRunID.optional = true
	return mmGetWorkflowRunID
}

// Expect sets up expected params for Github.GetWorkflowRunID
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) Expect(ctx context.Context, owner string, repo string, workflowName string, minRunVersion int) *mGithubMockGetWorkflowRunID {
	if mmGetWorkflowRunID.mock.funcGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Set")
	}

	if mmGetWorkflowRunID.defaultExpectation == nil {
		mmGetWorkflowRunID.defaultExpectation = &GithubMockGetWorkflowRunIDExpectation{}
	}

	if mmGetWorkflowRunID.defaultExpectation.paramPtrs != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by ExpectParams functions")
	}

	mmGetWorkflowRunID.defaultExpectation.params = &GithubMockGetWorkflowRunIDParams{ctx, owner, repo, workflowName, minRunVersion}
	for _, e := range mmGetWorkflowRunID.expectations {
		if minimock.Equal(e.params, mmGetWorkflowRunID.defaultExpectation.params) {
			mmGetWorkflowRunID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWorkflowRunID.defaultExpectation.params)
		}
	}

	return mmGetWorkflowRunID
}

// ExpectCtxParam1 sets up expected param ctx for Github.GetWorkflowRunID
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) ExpectCtxParam1(ctx context.Context) *mGithubMockGetWorkflowRunID {
	if mmGetWorkflowRunID.mock.funcGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Set")
	}

	if mmGetWorkflowRunID.defaultExpectation == nil {
		mmGetWorkflowRunID.defaultExpectation = &GithubMockGetWorkflowRunIDExpectation{}
	}

	if mmGetWorkflowRunID.defaultExpectation.params != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Expect")
	}

	if mmGetWorkflowRunID.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunID.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunIDParamPtrs{}
	}
	mmGetWorkflowRunID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetWorkflowRunID
}

// ExpectOwnerParam2 sets up expected param owner for Github.GetWorkflowRunID
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) ExpectOwnerParam2(owner string) *mGithubMockGetWorkflowRunID {
	if mmGetWorkflowRunID.mock.funcGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Set")
	}

	if mmGetWorkflowRunID.defaultExpectation == nil {
		mmGetWorkflowRunID.defaultExpectation = &GithubMockGetWorkflowRunIDExpectation{}
	}

	if mmGetWorkflowRunID.defaultExpectation.params != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Expect")
	}

	if mmGetWorkflowRunID.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunID.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunIDParamPtrs{}
	}
	mmGetWorkflowRunID.defaultExpectation.paramPtrs.owner = &owner

	return mmGetWorkflowRunID
}

// ExpectRepoParam3 sets up expected param repo for Github.GetWorkflowRunID
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) ExpectRepoParam3(repo string) *mGithubMockGetWorkflowRunID {
	if mmGetWorkflowRunID.mock.funcGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Set")
	}

	if mmGetWorkflowRunID.defaultExpectation == nil {
		mmGetWorkflowRunID.defaultExpectation = &GithubMockGetWorkflowRunIDExpectation{}
	}

	if mmGetWorkflowRunID.defaultExpectation.params != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Expect")
	}

	if mmGetWorkflowRunID.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunID.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunIDParamPtrs{}
	}
	mmGetWorkflowRunID.defaultExpectation.paramPtrs.repo = &repo

	return mmGetWorkflowRunID
}

// ExpectWorkflowNameParam4 sets up expected param workflowName for Github.GetWorkflowRunID
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) ExpectWorkflowNameParam4(workflowName string) *mGithubMockGetWorkflowRunID {
	if mmGetWorkflowRunID.mock.funcGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Set")
	}

	if mmGetWorkflowRunID.defaultExpectation == nil {
		mmGetWorkflowRunID.defaultExpectation = &GithubMockGetWorkflowRunIDExpectation{}
	}

	if mmGetWorkflowRunID.defaultExpectation.params != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Expect")
	}

	if mmGetWorkflowRunID.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunID.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunIDParamPtrs{}
	}
	mmGetWorkflowRunID.defaultExpectation.paramPtrs.workflowName = &workflowName

	return mmGetWorkflowRunID
}

// ExpectMinRunVersionParam5 sets up expected param minRunVersion for Github.GetWorkflowRunID
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) ExpectMinRunVersionParam5(minRunVersion int) *mGithubMockGetWorkflowRunID {
	if mmGetWorkflowRunID.mock.funcGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Set")
	}

	if mmGetWorkflowRunID.defaultExpectation == nil {
		mmGetWorkflowRunID.defaultExpectation = &GithubMockGetWorkflowRunIDExpectation{}
	}

	if mmGetWorkflowRunID.defaultExpectation.params != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Expect")
	}

	if mmGetWorkflowRunID.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunID.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunIDParamPtrs{}
	}
	mmGetWorkflowRunID.defaultExpectation.paramPtrs.minRunVersion = &minRunVersion

	return mmGetWorkflowRunID
}

// Inspect accepts an inspector function that has same arguments as the Github.GetWorkflowRunID
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) Inspect(f func(ctx context.Context, owner string, repo string, workflowName string, minRunVersion int)) *mGithubMockGetWorkflowRunID {
	if mmGetWorkflowRunID.mock.inspectFuncGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("Inspect function is already set for GithubMock.GetWorkflowRunID")
	}

	mmGetWorkflowRunID.mock.inspectFuncGetWorkflowRunID = f

	return mmGetWorkflowRunID
}

// Return sets up results that will be returned by Github.GetWorkflowRunID
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) Return(i1 int64, err error) *GithubMock {
	if mmGetWorkflowRunID.mock.funcGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Set")
	}

	if mmGetWorkflowRunID.defaultExpectation == nil {
		mmGetWorkflowRunID.defaultExpectation = &GithubMockGetWorkflowRunIDExpectation{mock: mmGetWorkflowRunID.mock}
	}
	mmGetWorkflowRunID.defaultExpectation.results = &GithubMockGetWorkflowRunIDResults{i1, err}
	return mmGetWorkflowRunID.mock
}

// Set uses given function f to mock the Github.GetWorkflowRunID method
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) Set(f func(ctx context.Context, owner string, repo string, workflowName string, minRunVersion int) (i1 int64, err error)) *GithubMock {
	if mmGetWorkflowRunID.defaultExpectation != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("Default expectation is already set for the Github.GetWorkflowRunID method")
	}

	if len(mmGetWorkflowRunID.expectations) > 0 {
		mmGetWorkflowRunID.mock.t.Fatalf("Some expectations are already set for the Github.GetWorkflowRunID method")
	}

	mmGetWorkflowRunID.mock.funcGetWorkflowRunID = f
	return mmGetWorkflowRunID.mock
}

// When sets expectation for the Github.GetWorkflowRunID which will trigger the result defined by the following
// Then helper
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) When(ctx context.Context, owner string, repo string, workflowName string, minRunVersion int) *GithubMockGetWorkflowRunIDExpectation {
	if mmGetWorkflowRunID.mock.funcGetWorkflowRunID != nil {
		mmGetWorkflowRunID.mock.t.Fatalf("GithubMock.GetWorkflowRunID mock is already set by Set")
	}

	expectation := &GithubMockGetWorkflowRunIDExpectation{
		mock:   mmGetWorkflowRunID.mock,
		params: &GithubMockGetWorkflowRunIDParams{ctx, owner, repo, workflowName, minRunVersion},
	}
	mmGetWorkflowRunID.expectations = append(mmGetWorkflowRunID.expectations, expectation)
	return expectation
}

// Then sets up Github.GetWorkflowRunID return parameters for the expectation previously defined by the When method
func (e *GithubMockGetWorkflowRunIDExpectation) Then(i1 int64, err error) *GithubMock {
	e.results = &GithubMockGetWorkflowRunIDResults{i1, err}
	return e.mock
}

// Times sets number of times Github.GetWorkflowRunID should be invoked
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) Times(n uint64) *mGithubMockGetWorkflowRunID {
	if n == 0 {
		mmGetWorkflowRunID.mock.t.Fatalf("Times of GithubMock.GetWorkflowRunID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWorkflowRunID.expectedInvocations, n)
	return mmGetWorkflowRunID
}

func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) invocationsDone() bool {
	if len(mmGetWorkflowRunID.expectations) == 0 && mmGetWorkflowRunID.defaultExpectation == nil && mmGetWorkflowRunID.mock.funcGetWorkflowRunID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWorkflowRunID.mock.afterGetWorkflowRunIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWorkflowRunID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWorkflowRunID implements Github
func (mmGetWorkflowRunID *GithubMock) GetWorkflowRunID(ctx context.Context, owner string, repo string, workflowName string, minRunVersion int) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetWorkflowRunID.beforeGetWorkflowRunIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWorkflowRunID.afterGetWorkflowRunIDCounter, 1)

	if mmGetWorkflowRunID.inspectFuncGetWorkflowRunID != nil {
		mmGetWorkflowRunID.inspectFuncGetWorkflowRunID(ctx, owner, repo, workflowName, minRunVersion)
	}

	mm_params := GithubMockGetWorkflowRunIDParams{ctx, owner, repo, workflowName, minRunVersion}

	// Record call args
	mmGetWorkflowRunID.GetWorkflowRunIDMock.mutex.Lock()
	mmGetWorkflowRunID.GetWorkflowRunIDMock.callArgs = append(mmGetWorkflowRunID.GetWorkflowRunIDMock.callArgs, &mm_params)
	mmGetWorkflowRunID.GetWorkflowRunIDMock.mutex.Unlock()

	for _, e := range mmGetWorkflowRunID.GetWorkflowRunIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetWorkflowRunID.GetWorkflowRunIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWorkflowRunID.GetWorkflowRunIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWorkflowRunID.GetWorkflowRunIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetWorkflowRunID.GetWorkflowRunIDMock.defaultExpectation.paramPtrs

		mm_got := GithubMockGetWorkflowRunIDParams{ctx, owner, repo, workflowName, minRunVersion}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetWorkflowRunID.t.Errorf("GithubMock.GetWorkflowRunID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.owner != nil && !minimock.Equal(*mm_want_ptrs.owner, mm_got.owner) {
				mmGetWorkflowRunID.t.Errorf("GithubMock.GetWorkflowRunID got unexpected parameter owner, want: %#v, got: %#v%s\n", *mm_want_ptrs.owner, mm_got.owner, minimock.Diff(*mm_want_ptrs.owner, mm_got.owner))
			}

			if mm_want_ptrs.repo != nil && !minimock.Equal(*mm_want_ptrs.repo, mm_got.repo) {
				mmGetWorkflowRunID.t.Errorf("GithubMock.GetWorkflowRunID got unexpected parameter repo, want: %#v, got: %#v%s\n", *mm_want_ptrs.repo, mm_got.repo, minimock.Diff(*mm_want_ptrs.repo, mm_got.repo))
			}

			if mm_want_ptrs.workflowName != nil && !minimock.Equal(*mm_want_ptrs.workflowName, mm_got.workflowName) {
				mmGetWorkflowRunID.t.Errorf("GithubMock.GetWorkflowRunID got unexpected parameter workflowName, want: %#v, got: %#v%s\n", *mm_want_ptrs.workflowName, mm_got.workflowName, minimock.Diff(*mm_want_ptrs.workflowName, mm_got.workflowName))
			}

			if mm_want_ptrs.minRunVersion != nil && !minimock.Equal(*mm_want_ptrs.minRunVersion, mm_got.minRunVersion) {
				mmGetWorkflowRunID.t.Errorf("GithubMock.GetWorkflowRunID got unexpected parameter minRunVersion, want: %#v, got: %#v%s\n", *mm_want_ptrs.minRunVersion, mm_got.minRunVersion, minimock.Diff(*mm_want_ptrs.minRunVersion, mm_got.minRunVersion))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWorkflowRunID.t.Errorf("GithubMock.GetWorkflowRunID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWorkflowRunID.GetWorkflowRunIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWorkflowRunID.t.Fatal("No results are set for the GithubMock.GetWorkflowRunID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetWorkflowRunID.funcGetWorkflowRunID != nil {
		return mmGetWorkflowRunID.funcGetWorkflowRunID(ctx, owner, repo, workflowName, minRunVersion)
	}
	mmGetWorkflowRunID.t.Fatalf("Unexpected call to GithubMock.GetWorkflowRunID. %v %v %v %v %v", ctx, owner, repo, workflowName, minRunVersion)
	return
}

// GetWorkflowRunIDAfterCounter returns a count of finished GithubMock.GetWorkflowRunID invocations
func (mmGetWorkflowRunID *GithubMock) GetWorkflowRunIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkflowRunID.afterGetWorkflowRunIDCounter)
}

// GetWorkflowRunIDBeforeCounter returns a count of GithubMock.GetWorkflowRunID invocations
func (mmGetWorkflowRunID *GithubMock) GetWorkflowRunIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkflowRunID.beforeGetWorkflowRunIDCounter)
}

// Calls returns a list of arguments used in each call to GithubMock.GetWorkflowRunID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWorkflowRunID *mGithubMockGetWorkflowRunID) Calls() []*GithubMockGetWorkflowRunIDParams {
	mmGetWorkflowRunID.mutex.RLock()

	argCopy := make([]*GithubMockGetWorkflowRunIDParams, len(mmGetWorkflowRunID.callArgs))
	copy(argCopy, mmGetWorkflowRunID.callArgs)

	mmGetWorkflowRunID.mutex.RUnlock()

	return argCopy
}

// MinimockGetWorkflowRunIDDone returns true if the count of the GetWorkflowRunID invocations corresponds
// the number of defined expectations
func (m *GithubMock) MinimockGetWorkflowRunIDDone() bool {
	if m.GetWorkflowRunIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWorkflowRunIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWorkflowRunIDMock.invocationsDone()
}

// MinimockGetWorkflowRunIDInspect logs each unmet expectation
func (m *GithubMock) MinimockGetWorkflowRunIDInspect() {
	for _, e := range m.GetWorkflowRunIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GithubMock.GetWorkflowRunID with params: %#v", *e.params)
		}
	}

	afterGetWorkflowRunIDCounter := mm_atomic.LoadUint64(&m.afterGetWorkflowRunIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkflowRunIDMock.defaultExpectation != nil && afterGetWorkflowRunIDCounter < 1 {
		if m.GetWorkflowRunIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GithubMock.GetWorkflowRunID")
		} else {
			m.t.Errorf("Expected call to GithubMock.GetWorkflowRunID with params: %#v", *m.GetWorkflowRunIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkflowRunID != nil && afterGetWorkflowRunIDCounter < 1 {
		m.t.Error("Expected call to GithubMock.GetWorkflowRunID")
	}

	if !m.GetWorkflowRunIDMock.invocationsDone() && afterGetWorkflowRunIDCounter > 0 {
		m.t.Errorf("Expected %d calls to GithubMock.GetWorkflowRunID but found %d calls",
			mm_atomic.LoadUint64(&m.GetWorkflowRunIDMock.expectedInvocations), afterGetWorkflowRunIDCounter)
	}
}

type mGithubMockGetWorkflowRunStatus struct {
	optional           bool
	mock               *GithubMock
	defaultExpectation *GithubMockGetWorkflowRunStatusExpectation
	expectations       []*GithubMockGetWorkflowRunStatusExpectation

	callArgs []*GithubMockGetWorkflowRunStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// GithubMockGetWorkflowRunStatusExpectation specifies expectation struct of the Github.GetWorkflowRunStatus
type GithubMockGetWorkflowRunStatusExpectation struct {
	mock      *GithubMock
	params    *GithubMockGetWorkflowRunStatusParams
	paramPtrs *GithubMockGetWorkflowRunStatusParamPtrs
	results   *GithubMockGetWorkflowRunStatusResults
	Counter   uint64
}

// GithubMockGetWorkflowRunStatusParams contains parameters of the Github.GetWorkflowRunStatus
type GithubMockGetWorkflowRunStatusParams struct {
	ctx   context.Context
	owner string
	repo  string
	runID int64
}

// GithubMockGetWorkflowRunStatusParamPtrs contains pointers to parameters of the Github.GetWorkflowRunStatus
type GithubMockGetWorkflowRunStatusParamPtrs struct {
	ctx   *context.Context
	owner *string
	repo  *string
	runID *int64
}

// GithubMockGetWorkflowRunStatusResults contains results of the Github.GetWorkflowRunStatus
type GithubMockGetWorkflowRunStatusResults struct {
	s1  string
	s2  string
	d1  time.Duration
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) Optional() *mGithubMockGetWorkflowRunStatus {
	mmGetWorkflowRunStatus.optional = true
	return mmGetWorkflowRunStatus
}

// Expect sets up expected params for Github.GetWorkflowRunStatus
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) Expect(ctx context.Context, owner string, repo string, runID int64) *mGithubMockGetWorkflowRunStatus {
	if mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Set")
	}

	if mmGetWorkflowRunStatus.defaultExpectation == nil {
		mmGetWorkflowRunStatus.defaultExpectation = &GithubMockGetWorkflowRunStatusExpectation{}
	}

	if mmGetWorkflowRunStatus.defaultExpectation.paramPtrs != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by ExpectParams functions")
	}

	mmGetWorkflowRunStatus.defaultExpectation.params = &GithubMockGetWorkflowRunStatusParams{ctx, owner, repo, runID}
	for _, e := range mmGetWorkflowRunStatus.expectations {
		if minimock.Equal(e.params, mmGetWorkflowRunStatus.defaultExpectation.params) {
			mmGetWorkflowRunStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWorkflowRunStatus.defaultExpectation.params)
		}
	}

	return mmGetWorkflowRunStatus
}

// ExpectCtxParam1 sets up expected param ctx for Github.GetWorkflowRunStatus
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) ExpectCtxParam1(ctx context.Context) *mGithubMockGetWorkflowRunStatus {
	if mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Set")
	}

	if mmGetWorkflowRunStatus.defaultExpectation == nil {
		mmGetWorkflowRunStatus.defaultExpectation = &GithubMockGetWorkflowRunStatusExpectation{}
	}

	if mmGetWorkflowRunStatus.defaultExpectation.params != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Expect")
	}

	if mmGetWorkflowRunStatus.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunStatus.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunStatusParamPtrs{}
	}
	mmGetWorkflowRunStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetWorkflowRunStatus
}

// ExpectOwnerParam2 sets up expected param owner for Github.GetWorkflowRunStatus
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) ExpectOwnerParam2(owner string) *mGithubMockGetWorkflowRunStatus {
	if mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Set")
	}

	if mmGetWorkflowRunStatus.defaultExpectation == nil {
		mmGetWorkflowRunStatus.defaultExpectation = &GithubMockGetWorkflowRunStatusExpectation{}
	}

	if mmGetWorkflowRunStatus.defaultExpectation.params != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Expect")
	}

	if mmGetWorkflowRunStatus.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunStatus.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunStatusParamPtrs{}
	}
	mmGetWorkflowRunStatus.defaultExpectation.paramPtrs.owner = &owner

	return mmGetWorkflowRunStatus
}

// ExpectRepoParam3 sets up expected param repo for Github.GetWorkflowRunStatus
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) ExpectRepoParam3(repo string) *mGithubMockGetWorkflowRunStatus {
	if mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Set")
	}

	if mmGetWorkflowRunStatus.defaultExpectation == nil {
		mmGetWorkflowRunStatus.defaultExpectation = &GithubMockGetWorkflowRunStatusExpectation{}
	}

	if mmGetWorkflowRunStatus.defaultExpectation.params != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Expect")
	}

	if mmGetWorkflowRunStatus.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunStatus.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunStatusParamPtrs{}
	}
	mmGetWorkflowRunStatus.defaultExpectation.paramPtrs.repo = &repo

	return mmGetWorkflowRunStatus
}

// ExpectRunIDParam4 sets up expected param runID for Github.GetWorkflowRunStatus
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) ExpectRunIDParam4(runID int64) *mGithubMockGetWorkflowRunStatus {
	if mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Set")
	}

	if mmGetWorkflowRunStatus.defaultExpectation == nil {
		mmGetWorkflowRunStatus.defaultExpectation = &GithubMockGetWorkflowRunStatusExpectation{}
	}

	if mmGetWorkflowRunStatus.defaultExpectation.params != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Expect")
	}

	if mmGetWorkflowRunStatus.defaultExpectation.paramPtrs == nil {
		mmGetWorkflowRunStatus.defaultExpectation.paramPtrs = &GithubMockGetWorkflowRunStatusParamPtrs{}
	}
	mmGetWorkflowRunStatus.defaultExpectation.paramPtrs.runID = &runID

	return mmGetWorkflowRunStatus
}

// Inspect accepts an inspector function that has same arguments as the Github.GetWorkflowRunStatus
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) Inspect(f func(ctx context.Context, owner string, repo string, runID int64)) *mGithubMockGetWorkflowRunStatus {
	if mmGetWorkflowRunStatus.mock.inspectFuncGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("Inspect function is already set for GithubMock.GetWorkflowRunStatus")
	}

	mmGetWorkflowRunStatus.mock.inspectFuncGetWorkflowRunStatus = f

	return mmGetWorkflowRunStatus
}

// Return sets up results that will be returned by Github.GetWorkflowRunStatus
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) Return(s1 string, s2 string, d1 time.Duration, err error) *GithubMock {
	if mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Set")
	}

	if mmGetWorkflowRunStatus.defaultExpectation == nil {
		mmGetWorkflowRunStatus.defaultExpectation = &GithubMockGetWorkflowRunStatusExpectation{mock: mmGetWorkflowRunStatus.mock}
	}
	mmGetWorkflowRunStatus.defaultExpectation.results = &GithubMockGetWorkflowRunStatusResults{s1, s2, d1, err}
	return mmGetWorkflowRunStatus.mock
}

// Set uses given function f to mock the Github.GetWorkflowRunStatus method
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) Set(f func(ctx context.Context, owner string, repo string, runID int64) (s1 string, s2 string, d1 time.Duration, err error)) *GithubMock {
	if mmGetWorkflowRunStatus.defaultExpectation != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("Default expectation is already set for the Github.GetWorkflowRunStatus method")
	}

	if len(mmGetWorkflowRunStatus.expectations) > 0 {
		mmGetWorkflowRunStatus.mock.t.Fatalf("Some expectations are already set for the Github.GetWorkflowRunStatus method")
	}

	mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus = f
	return mmGetWorkflowRunStatus.mock
}

// When sets expectation for the Github.GetWorkflowRunStatus which will trigger the result defined by the following
// Then helper
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) When(ctx context.Context, owner string, repo string, runID int64) *GithubMockGetWorkflowRunStatusExpectation {
	if mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.mock.t.Fatalf("GithubMock.GetWorkflowRunStatus mock is already set by Set")
	}

	expectation := &GithubMockGetWorkflowRunStatusExpectation{
		mock:   mmGetWorkflowRunStatus.mock,
		params: &GithubMockGetWorkflowRunStatusParams{ctx, owner, repo, runID},
	}
	mmGetWorkflowRunStatus.expectations = append(mmGetWorkflowRunStatus.expectations, expectation)
	return expectation
}

// Then sets up Github.GetWorkflowRunStatus return parameters for the expectation previously defined by the When method
func (e *GithubMockGetWorkflowRunStatusExpectation) Then(s1 string, s2 string, d1 time.Duration, err error) *GithubMock {
	e.results = &GithubMockGetWorkflowRunStatusResults{s1, s2, d1, err}
	return e.mock
}

// Times sets number of times Github.GetWorkflowRunStatus should be invoked
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) Times(n uint64) *mGithubMockGetWorkflowRunStatus {
	if n == 0 {
		mmGetWorkflowRunStatus.mock.t.Fatalf("Times of GithubMock.GetWorkflowRunStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWorkflowRunStatus.expectedInvocations, n)
	return mmGetWorkflowRunStatus
}

func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) invocationsDone() bool {
	if len(mmGetWorkflowRunStatus.expectations) == 0 && mmGetWorkflowRunStatus.defaultExpectation == nil && mmGetWorkflowRunStatus.mock.funcGetWorkflowRunStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWorkflowRunStatus.mock.afterGetWorkflowRunStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWorkflowRunStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWorkflowRunStatus implements Github
func (mmGetWorkflowRunStatus *GithubMock) GetWorkflowRunStatus(ctx context.Context, owner string, repo string, runID int64) (s1 string, s2 string, d1 time.Duration, err error) {
	mm_atomic.AddUint64(&mmGetWorkflowRunStatus.beforeGetWorkflowRunStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWorkflowRunStatus.afterGetWorkflowRunStatusCounter, 1)

	if mmGetWorkflowRunStatus.inspectFuncGetWorkflowRunStatus != nil {
		mmGetWorkflowRunStatus.inspectFuncGetWorkflowRunStatus(ctx, owner, repo, runID)
	}

	mm_params := GithubMockGetWorkflowRunStatusParams{ctx, owner, repo, runID}

	// Record call args
	mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.mutex.Lock()
	mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.callArgs = append(mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.callArgs, &mm_params)
	mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.mutex.Unlock()

	for _, e := range mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.s2, e.results.d1, e.results.err
		}
	}

	if mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.defaultExpectation.params
		mm_want_ptrs := mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.defaultExpectation.paramPtrs

		mm_got := GithubMockGetWorkflowRunStatusParams{ctx, owner, repo, runID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetWorkflowRunStatus.t.Errorf("GithubMock.GetWorkflowRunStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.owner != nil && !minimock.Equal(*mm_want_ptrs.owner, mm_got.owner) {
				mmGetWorkflowRunStatus.t.Errorf("GithubMock.GetWorkflowRunStatus got unexpected parameter owner, want: %#v, got: %#v%s\n", *mm_want_ptrs.owner, mm_got.owner, minimock.Diff(*mm_want_ptrs.owner, mm_got.owner))
			}

			if mm_want_ptrs.repo != nil && !minimock.Equal(*mm_want_ptrs.repo, mm_got.repo) {
				mmGetWorkflowRunStatus.t.Errorf("GithubMock.GetWorkflowRunStatus got unexpected parameter repo, want: %#v, got: %#v%s\n", *mm_want_ptrs.repo, mm_got.repo, minimock.Diff(*mm_want_ptrs.repo, mm_got.repo))
			}

			if mm_want_ptrs.runID != nil && !minimock.Equal(*mm_want_ptrs.runID, mm_got.runID) {
				mmGetWorkflowRunStatus.t.Errorf("GithubMock.GetWorkflowRunStatus got unexpected parameter runID, want: %#v, got: %#v%s\n", *mm_want_ptrs.runID, mm_got.runID, minimock.Diff(*mm_want_ptrs.runID, mm_got.runID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWorkflowRunStatus.t.Errorf("GithubMock.GetWorkflowRunStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWorkflowRunStatus.GetWorkflowRunStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWorkflowRunStatus.t.Fatal("No results are set for the GithubMock.GetWorkflowRunStatus")
		}
		return (*mm_results).s1, (*mm_results).s2, (*mm_results).d1, (*mm_results).err
	}
	if mmGetWorkflowRunStatus.funcGetWorkflowRunStatus != nil {
		return mmGetWorkflowRunStatus.funcGetWorkflowRunStatus(ctx, owner, repo, runID)
	}
	mmGetWorkflowRunStatus.t.Fatalf("Unexpected call to GithubMock.GetWorkflowRunStatus. %v %v %v %v", ctx, owner, repo, runID)
	return
}

// GetWorkflowRunStatusAfterCounter returns a count of finished GithubMock.GetWorkflowRunStatus invocations
func (mmGetWorkflowRunStatus *GithubMock) GetWorkflowRunStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkflowRunStatus.afterGetWorkflowRunStatusCounter)
}

// GetWorkflowRunStatusBeforeCounter returns a count of GithubMock.GetWorkflowRunStatus invocations
func (mmGetWorkflowRunStatus *GithubMock) GetWorkflowRunStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkflowRunStatus.beforeGetWorkflowRunStatusCounter)
}

// Calls returns a list of arguments used in each call to GithubMock.GetWorkflowRunStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWorkflowRunStatus *mGithubMockGetWorkflowRunStatus) Calls() []*GithubMockGetWorkflowRunStatusParams {
	mmGetWorkflowRunStatus.mutex.RLock()

	argCopy := make([]*GithubMockGetWorkflowRunStatusParams, len(mmGetWorkflowRunStatus.callArgs))
	copy(argCopy, mmGetWorkflowRunStatus.callArgs)

	mmGetWorkflowRunStatus.mutex.RUnlock()

	return argCopy
}

// MinimockGetWorkflowRunStatusDone returns true if the count of the GetWorkflowRunStatus invocations corresponds
// the number of defined expectations
func (m *GithubMock) MinimockGetWorkflowRunStatusDone() bool {
	if m.GetWorkflowRunStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWorkflowRunStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWorkflowRunStatusMock.invocationsDone()
}

// MinimockGetWorkflowRunStatusInspect logs each unmet expectation
func (m *GithubMock) MinimockGetWorkflowRunStatusInspect() {
	for _, e := range m.GetWorkflowRunStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GithubMock.GetWorkflowRunStatus with params: %#v", *e.params)
		}
	}

	afterGetWorkflowRunStatusCounter := mm_atomic.LoadUint64(&m.afterGetWorkflowRunStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkflowRunStatusMock.defaultExpectation != nil && afterGetWorkflowRunStatusCounter < 1 {
		if m.GetWorkflowRunStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GithubMock.GetWorkflowRunStatus")
		} else {
			m.t.Errorf("Expected call to GithubMock.GetWorkflowRunStatus with params: %#v", *m.GetWorkflowRunStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkflowRunStatus != nil && afterGetWorkflowRunStatusCounter < 1 {
		m.t.Error("Expected call to GithubMock.GetWorkflowRunStatus")
	}

	if !m.GetWorkflowRunStatusMock.invocationsDone() && afterGetWorkflowRunStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to GithubMock.GetWorkflowRunStatus but found %d calls",
			mm_atomic.LoadUint64(&m.GetWorkflowRunStatusMock.expectedInvocations), afterGetWorkflowRunStatusCounter)
	}
}

type mGithubMockTriggerWorkflow struct {
	optional           bool
	mock               *GithubMock
	defaultExpectation *GithubMockTriggerWorkflowExpectation
	expectations       []*GithubMockTriggerWorkflowExpectation

	callArgs []*GithubMockTriggerWorkflowParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// GithubMockTriggerWorkflowExpectation specifies expectation struct of the Github.TriggerWorkflow
type GithubMockTriggerWorkflowExpectation struct {
	mock      *GithubMock
	params    *GithubMockTriggerWorkflowParams
	paramPtrs *GithubMockTriggerWorkflowParamPtrs
	results   *GithubMockTriggerWorkflowResults
	Counter   uint64
}

// GithubMockTriggerWorkflowParams contains parameters of the Github.TriggerWorkflow
type GithubMockTriggerWorkflowParams struct {
	ctx       context.Context
	owner     string
	repo      string
	workflow  string
	eventType string
	params    map[string]interface{}
}

// GithubMockTriggerWorkflowParamPtrs contains pointers to parameters of the Github.TriggerWorkflow
type GithubMockTriggerWorkflowParamPtrs struct {
	ctx       *context.Context
	owner     *string
	repo      *string
	workflow  *string
	eventType *string
	params    *map[string]interface{}
}

// GithubMockTriggerWorkflowResults contains results of the Github.TriggerWorkflow
type GithubMockTriggerWorkflowResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) Optional() *mGithubMockTriggerWorkflow {
	mmTriggerWorkflow.optional = true
	return mmTriggerWorkflow
}

// Expect sets up expected params for Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) Expect(ctx context.Context, owner string, repo string, workflow string, eventType string, params map[string]interface{}) *mGithubMockTriggerWorkflow {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	if mmTriggerWorkflow.defaultExpectation == nil {
		mmTriggerWorkflow.defaultExpectation = &GithubMockTriggerWorkflowExpectation{}
	}

	if mmTriggerWorkflow.defaultExpectation.paramPtrs != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by ExpectParams functions")
	}

	mmTriggerWorkflow.defaultExpectation.params = &GithubMockTriggerWorkflowParams{ctx, owner, repo, workflow, eventType, params}
	for _, e := range mmTriggerWorkflow.expectations {
		if minimock.Equal(e.params, mmTriggerWorkflow.defaultExpectation.params) {
			mmTriggerWorkflow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerWorkflow.defaultExpectation.params)
		}
	}

	return mmTriggerWorkflow
}

// ExpectCtxParam1 sets up expected param ctx for Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) ExpectCtxParam1(ctx context.Context) *mGithubMockTriggerWorkflow {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	if mmTriggerWorkflow.defaultExpectation == nil {
		mmTriggerWorkflow.defaultExpectation = &GithubMockTriggerWorkflowExpectation{}
	}

	if mmTriggerWorkflow.defaultExpectation.params != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Expect")
	}

	if mmTriggerWorkflow.defaultExpectation.paramPtrs == nil {
		mmTriggerWorkflow.defaultExpectation.paramPtrs = &GithubMockTriggerWorkflowParamPtrs{}
	}
	mmTriggerWorkflow.defaultExpectation.paramPtrs.ctx = &ctx

	return mmTriggerWorkflow
}

// ExpectOwnerParam2 sets up expected param owner for Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) ExpectOwnerParam2(owner string) *mGithubMockTriggerWorkflow {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	if mmTriggerWorkflow.defaultExpectation == nil {
		mmTriggerWorkflow.defaultExpectation = &GithubMockTriggerWorkflowExpectation{}
	}

	if mmTriggerWorkflow.defaultExpectation.params != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Expect")
	}

	if mmTriggerWorkflow.defaultExpectation.paramPtrs == nil {
		mmTriggerWorkflow.defaultExpectation.paramPtrs = &GithubMockTriggerWorkflowParamPtrs{}
	}
	mmTriggerWorkflow.defaultExpectation.paramPtrs.owner = &owner

	return mmTriggerWorkflow
}

// ExpectRepoParam3 sets up expected param repo for Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) ExpectRepoParam3(repo string) *mGithubMockTriggerWorkflow {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	if mmTriggerWorkflow.defaultExpectation == nil {
		mmTriggerWorkflow.defaultExpectation = &GithubMockTriggerWorkflowExpectation{}
	}

	if mmTriggerWorkflow.defaultExpectation.params != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Expect")
	}

	if mmTriggerWorkflow.defaultExpectation.paramPtrs == nil {
		mmTriggerWorkflow.defaultExpectation.paramPtrs = &GithubMockTriggerWorkflowParamPtrs{}
	}
	mmTriggerWorkflow.defaultExpectation.paramPtrs.repo = &repo

	return mmTriggerWorkflow
}

// ExpectWorkflowParam4 sets up expected param workflow for Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) ExpectWorkflowParam4(workflow string) *mGithubMockTriggerWorkflow {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	if mmTriggerWorkflow.defaultExpectation == nil {
		mmTriggerWorkflow.defaultExpectation = &GithubMockTriggerWorkflowExpectation{}
	}

	if mmTriggerWorkflow.defaultExpectation.params != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Expect")
	}

	if mmTriggerWorkflow.defaultExpectation.paramPtrs == nil {
		mmTriggerWorkflow.defaultExpectation.paramPtrs = &GithubMockTriggerWorkflowParamPtrs{}
	}
	mmTriggerWorkflow.defaultExpectation.paramPtrs.workflow = &workflow

	return mmTriggerWorkflow
}

// ExpectEventTypeParam5 sets up expected param eventType for Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) ExpectEventTypeParam5(eventType string) *mGithubMockTriggerWorkflow {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	if mmTriggerWorkflow.defaultExpectation == nil {
		mmTriggerWorkflow.defaultExpectation = &GithubMockTriggerWorkflowExpectation{}
	}

	if mmTriggerWorkflow.defaultExpectation.params != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Expect")
	}

	if mmTriggerWorkflow.defaultExpectation.paramPtrs == nil {
		mmTriggerWorkflow.defaultExpectation.paramPtrs = &GithubMockTriggerWorkflowParamPtrs{}
	}
	mmTriggerWorkflow.defaultExpectation.paramPtrs.eventType = &eventType

	return mmTriggerWorkflow
}

// ExpectParamsParam6 sets up expected param params for Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) ExpectParamsParam6(params map[string]interface{}) *mGithubMockTriggerWorkflow {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	if mmTriggerWorkflow.defaultExpectation == nil {
		mmTriggerWorkflow.defaultExpectation = &GithubMockTriggerWorkflowExpectation{}
	}

	if mmTriggerWorkflow.defaultExpectation.params != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Expect")
	}

	if mmTriggerWorkflow.defaultExpectation.paramPtrs == nil {
		mmTriggerWorkflow.defaultExpectation.paramPtrs = &GithubMockTriggerWorkflowParamPtrs{}
	}
	mmTriggerWorkflow.defaultExpectation.paramPtrs.params = &params

	return mmTriggerWorkflow
}

// Inspect accepts an inspector function that has same arguments as the Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) Inspect(f func(ctx context.Context, owner string, repo string, workflow string, eventType string, params map[string]interface{})) *mGithubMockTriggerWorkflow {
	if mmTriggerWorkflow.mock.inspectFuncTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("Inspect function is already set for GithubMock.TriggerWorkflow")
	}

	mmTriggerWorkflow.mock.inspectFuncTriggerWorkflow = f

	return mmTriggerWorkflow
}

// Return sets up results that will be returned by Github.TriggerWorkflow
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) Return(err error) *GithubMock {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	if mmTriggerWorkflow.defaultExpectation == nil {
		mmTriggerWorkflow.defaultExpectation = &GithubMockTriggerWorkflowExpectation{mock: mmTriggerWorkflow.mock}
	}
	mmTriggerWorkflow.defaultExpectation.results = &GithubMockTriggerWorkflowResults{err}
	return mmTriggerWorkflow.mock
}

// Set uses given function f to mock the Github.TriggerWorkflow method
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) Set(f func(ctx context.Context, owner string, repo string, workflow string, eventType string, params map[string]interface{}) (err error)) *GithubMock {
	if mmTriggerWorkflow.defaultExpectation != nil {
		mmTriggerWorkflow.mock.t.Fatalf("Default expectation is already set for the Github.TriggerWorkflow method")
	}

	if len(mmTriggerWorkflow.expectations) > 0 {
		mmTriggerWorkflow.mock.t.Fatalf("Some expectations are already set for the Github.TriggerWorkflow method")
	}

	mmTriggerWorkflow.mock.funcTriggerWorkflow = f
	return mmTriggerWorkflow.mock
}

// When sets expectation for the Github.TriggerWorkflow which will trigger the result defined by the following
// Then helper
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) When(ctx context.Context, owner string, repo string, workflow string, eventType string, params map[string]interface{}) *GithubMockTriggerWorkflowExpectation {
	if mmTriggerWorkflow.mock.funcTriggerWorkflow != nil {
		mmTriggerWorkflow.mock.t.Fatalf("GithubMock.TriggerWorkflow mock is already set by Set")
	}

	expectation := &GithubMockTriggerWorkflowExpectation{
		mock:   mmTriggerWorkflow.mock,
		params: &GithubMockTriggerWorkflowParams{ctx, owner, repo, workflow, eventType, params},
	}
	mmTriggerWorkflow.expectations = append(mmTriggerWorkflow.expectations, expectation)
	return expectation
}

// Then sets up Github.TriggerWorkflow return parameters for the expectation previously defined by the When method
func (e *GithubMockTriggerWorkflowExpectation) Then(err error) *GithubMock {
	e.results = &GithubMockTriggerWorkflowResults{err}
	return e.mock
}

// Times sets number of times Github.TriggerWorkflow should be invoked
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) Times(n uint64) *mGithubMockTriggerWorkflow {
	if n == 0 {
		mmTriggerWorkflow.mock.t.Fatalf("Times of GithubMock.TriggerWorkflow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerWorkflow.expectedInvocations, n)
	return mmTriggerWorkflow
}

func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) invocationsDone() bool {
	if len(mmTriggerWorkflow.expectations) == 0 && mmTriggerWorkflow.defaultExpectation == nil && mmTriggerWorkflow.mock.funcTriggerWorkflow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerWorkflow.mock.afterTriggerWorkflowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerWorkflow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerWorkflow implements Github
func (mmTriggerWorkflow *GithubMock) TriggerWorkflow(ctx context.Context, owner string, repo string, workflow string, eventType string, params map[string]interface{}) (err error) {
	mm_atomic.AddUint64(&mmTriggerWorkflow.beforeTriggerWorkflowCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerWorkflow.afterTriggerWorkflowCounter, 1)

	if mmTriggerWorkflow.inspectFuncTriggerWorkflow != nil {
		mmTriggerWorkflow.inspectFuncTriggerWorkflow(ctx, owner, repo, workflow, eventType, params)
	}

	mm_params := GithubMockTriggerWorkflowParams{ctx, owner, repo, workflow, eventType, params}

	// Record call args
	mmTriggerWorkflow.TriggerWorkflowMock.mutex.Lock()
	mmTriggerWorkflow.TriggerWorkflowMock.callArgs = append(mmTriggerWorkflow.TriggerWorkflowMock.callArgs, &mm_params)
	mmTriggerWorkflow.TriggerWorkflowMock.mutex.Unlock()

	for _, e := range mmTriggerWorkflow.TriggerWorkflowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTriggerWorkflow.TriggerWorkflowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerWorkflow.TriggerWorkflowMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerWorkflow.TriggerWorkflowMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerWorkflow.TriggerWorkflowMock.defaultExpectation.paramPtrs

		mm_got := GithubMockTriggerWorkflowParams{ctx, owner, repo, workflow, eventType, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerWorkflow.t.Errorf("GithubMock.TriggerWorkflow got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.owner != nil && !minimock.Equal(*mm_want_ptrs.owner, mm_got.owner) {
				mmTriggerWorkflow.t.Errorf("GithubMock.TriggerWorkflow got unexpected parameter owner, want: %#v, got: %#v%s\n", *mm_want_ptrs.owner, mm_got.owner, minimock.Diff(*mm_want_ptrs.owner, mm_got.owner))
			}

			if mm_want_ptrs.repo != nil && !minimock.Equal(*mm_want_ptrs.repo, mm_got.repo) {
				mmTriggerWorkflow.t.Errorf("GithubMock.TriggerWorkflow got unexpected parameter repo, want: %#v, got: %#v%s\n", *mm_want_ptrs.repo, mm_got.repo, minimock.Diff(*mm_want_ptrs.repo, mm_got.repo))
			}

			if mm_want_ptrs.workflow != nil && !minimock.Equal(*mm_want_ptrs.workflow, mm_got.workflow) {
				mmTriggerWorkflow.t.Errorf("GithubMock.TriggerWorkflow got unexpected parameter workflow, want: %#v, got: %#v%s\n", *mm_want_ptrs.workflow, mm_got.workflow, minimock.Diff(*mm_want_ptrs.workflow, mm_got.workflow))
			}

			if mm_want_ptrs.eventType != nil && !minimock.Equal(*mm_want_ptrs.eventType, mm_got.eventType) {
				mmTriggerWorkflow.t.Errorf("GithubMock.TriggerWorkflow got unexpected parameter eventType, want: %#v, got: %#v%s\n", *mm_want_ptrs.eventType, mm_got.eventType, minimock.Diff(*mm_want_ptrs.eventType, mm_got.eventType))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmTriggerWorkflow.t.Errorf("GithubMock.TriggerWorkflow got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerWorkflow.t.Errorf("GithubMock.TriggerWorkflow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerWorkflow.TriggerWorkflowMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerWorkflow.t.Fatal("No results are set for the GithubMock.TriggerWorkflow")
		}
		return (*mm_results).err
	}
	if mmTriggerWorkflow.funcTriggerWorkflow != nil {
		return mmTriggerWorkflow.funcTriggerWorkflow(ctx, owner, repo, workflow, eventType, params)
	}
	mmTriggerWorkflow.t.Fatalf("Unexpected call to GithubMock.TriggerWorkflow. %v %v %v %v %v %v", ctx, owner, repo, workflow, eventType, params)
	return
}

// TriggerWorkflowAfterCounter returns a count of finished GithubMock.TriggerWorkflow invocations
func (mmTriggerWorkflow *GithubMock) TriggerWorkflowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerWorkflow.afterTriggerWorkflowCounter)
}

// TriggerWorkflowBeforeCounter returns a count of GithubMock.TriggerWorkflow invocations
func (mmTriggerWorkflow *GithubMock) TriggerWorkflowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerWorkflow.beforeTriggerWorkflowCounter)
}

// Calls returns a list of arguments used in each call to GithubMock.TriggerWorkflow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerWorkflow *mGithubMockTriggerWorkflow) Calls() []*GithubMockTriggerWorkflowParams {
	mmTriggerWorkflow.mutex.RLock()

	argCopy := make([]*GithubMockTriggerWorkflowParams, len(mmTriggerWorkflow.callArgs))
	copy(argCopy, mmTriggerWorkflow.callArgs)

	mmTriggerWorkflow.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerWorkflowDone returns true if the count of the TriggerWorkflow invocations corresponds
// the number of defined expectations
func (m *GithubMock) MinimockTriggerWorkflowDone() bool {
	if m.TriggerWorkflowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerWorkflowMock.invocationsDone()
}

// MinimockTriggerWorkflowInspect logs each unmet expectation
func (m *GithubMock) MinimockTriggerWorkflowInspect() {
	for _, e := range m.TriggerWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GithubMock.TriggerWorkflow with params: %#v", *e.params)
		}
	}

	afterTriggerWorkflowCounter := mm_atomic.LoadUint64(&m.afterTriggerWorkflowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerWorkflowMock.defaultExpectation != nil && afterTriggerWorkflowCounter < 1 {
		if m.TriggerWorkflowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GithubMock.TriggerWorkflow")
		} else {
			m.t.Errorf("Expected call to GithubMock.TriggerWorkflow with params: %#v", *m.TriggerWorkflowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerWorkflow != nil && afterTriggerWorkflowCounter < 1 {
		m.t.Error("Expected call to GithubMock.TriggerWorkflow")
	}

	if !m.TriggerWorkflowMock.invocationsDone() && afterTriggerWorkflowCounter > 0 {
		m.t.Errorf("Expected %d calls to GithubMock.TriggerWorkflow but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerWorkflowMock.expectedInvocations), afterTriggerWorkflowCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GithubMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelWorkflowRunInspect()

			m.MinimockGetLastWorkflowRunNumberInspect()

			m.MinimockGetWorkflowRunIDInspect()

			m.MinimockGetWorkflowRunStatusInspect()

			m.MinimockTriggerWorkflowInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GithubMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GithubMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelWorkflowRunDone() &&
		m.MinimockGetLastWorkflowRunNumberDone() &&
		m.MinimockGetWorkflowRunIDDone() &&
		m.MinimockGetWorkflowRunStatusDone() &&
		m.MinimockTriggerWorkflowDone()
}
